def KEEP_IMAGE = true // whether you wnat your iamge to be pushed to Dockerhub or not. Image gets pushed by default for develop and master branches.
def devops_repo_branch = "master" // Branch of teh devops repository. Default is master.
def appName = 'LogframeLab' // Name of the app used in Terraform.

/* ENVIRONMENT BRANCHES used to Deploy*/
environment_branches = ['develop', 'master', 'feature/ecs-dev']

pipeline {
    agent any
    tools {
        nodejs 'Node'
    }

    stages {

        stage('Dependencies') {
            steps {
                sh 'CYPRESS_CACHE_FOLDER=/root/.cache/Cypress npm install'
            }
        }

        stage('Compile and Bundle the app') {
            steps {
                script {
                    if (env.BRANCH_NAME == 'master' || env.BRANCH_NAME == 'feature/ecs-dev') {
                        sh 'CYPRESS_CACHE_FOLDER=/root/.cache/Cypress node node_modules/@angular/cli/bin/ng build --prod --buildOptimizer --verbose'
                    } else {
                        sh 'node node_modules/@angular/cli/bin/ng build --configuration=development --buildOptimizer --verbose'
                    }
                }
            }
        }
        
        stage('Test') {
            steps {
                sh 'npm run test:docker'
            }
        }

        stage('Test E2E') {
            steps {
                sh 'CYPRESS_CACHE_FOLDER=/root/.cache/Cypress CYPRESS_RETRIES=2 npm run e2e:ci'
            }
            post {
                success {
                    junit 'results/cypress-report.xml'
                }
            }

        }
        stage ('Build Docker Image') {
            steps {
                script {
                    def dockerfile = "${env.WORKSPACE}/Dockerfile"

                    // Read version from packer.json
                    def config = readJSON file: "${env.WORKSPACE}/package.json"
                    env.image_version = "${config.version}"

                    // Determine Image Tag
                    GIT_HASH = sh(returnStdout: true, script: "git rev-parse --short HEAD").trim()
                    def commit_id = GIT_HASH
                    env.image_name = 'client'
                    env.image_tag = "${env.BRANCH_NAME != 'master' || env.BRANCH_NAME != 'develop' ? 'feature-' + commit_id : env.BUILD_NUMBER}"
                    sh "docker build -t ${image_name}:${image_version}-${image_tag} ."
                }
            }
        }

        stage ('Tag and Push Docker Image') {
            when {
                expression {
                    return env.BRANCH_NAME in environment_branches || KEEP_IMAGE == true;
                    // Run only for stable branches and not PRs
                }
            }
            steps {
                script {
                    if (env.BRANCH_NAME == 'develop') {
                        sh "docker tag ${env.image_name}:${ienv.mage_version}-${env.image_tag} logframelab/${env.image_name}:${env.image_version}-${env.image_tag}"
                        sh "docker tag ${env.image_name}:${env.image_version}-${env.image_tag} logframelab/${env.image_name}:devlatest"
                        withDockerRegistry(url: 'https://index.docker.io/v1/',  credentialsId: 'dockerhub') {
                            sh "docker push logframelab/${env.image_name}:${env.image_version}-${env.image_tag}"
                            sh "docker push logframelab/${env.image_name}:devlatest"
                        }
                        // Set Deployment variables
                        env.TERRAFORM_ENVIRONMENT = 'dev'
                        env.CLIENT_IMAGE_TAG = 'devlatest'
                        env.SERVER_IMAGE_TAG = 'devlatest'
                    }

                    if (env.BRANCH_NAME == 'master') {
                        sh "docker tag ${env.image_name}:${env.image_version}-${env.image_tag} logframelab/${env.image_name}:${env.image_version}-${env.image_tag}"
                        sh "docker tag ${env.image_name}:${env.image_version}-${env.image_tag} logframelab/${env.image_name}:stagelatest"
                        withDockerRegistry(url: 'https://index.docker.io/v1/',  credentialsId: 'dockerhub') {
                            sh "docker push logframelab/${env.image_name}:${env.image_version}-${env.image_tag}"
                            sh "docker push logframelab/${env.image_name}:stagelatest"
                        }
                        // Set Deployment variables
                        env.TERRAFORM_ENVIRONMENT = 'stage'
                        env.CLIENT_IMAGE_TAG = 'stagelatest'
                        env.SERVER_IMAGE_TAG = 'stagelatest'
                    }

                    if (KEEP_IMAGE == true) {
                        sh "docker tag ${env.image_name}:${env.image_version}-${env.image_tag} logframelab/${env.image_name}:${env.image_version}-${env.image_tag}"
                        withDockerRegistry(url: 'https://index.docker.io/v1/',  credentialsId: 'dockerhub') {
                            sh "docker push logframelab/${env.image_name}:${env.image_version}-${env.image_tag}"
                        }
                    }
                    // SECTION TO BE REMOVED
                    if (env.BRANCH_NAME == 'feature/ecs-dev') {
                        env.TERRAFORM_ENVIRONMENT = 'stage'
                        env.CLIENT_IMAGE_TAG = env.image_tag
                        env.SERVER_IMAGE_TAG = 'stagelatest'
                    }
                }
            }
        }

        stage ('Invoke Terraform: Provisioner:base_resources, Action:plan') {
            when {
                expression {
                    return env.BRANCH_NAME in environment_branches;
                    // Run only for stable branches and not PRs
                }
            }
            steps {
                build job: 'Deployments/Terraform-Deployment-Pipeline',
                wait: true,
                parameters: [
                    string(name: 'ENV', value: env.TERRAFORM_ENVIRONMENT),
                    string(name: 'ACTION', value: "plan"),
                    string(name: 'PROVISIONER', value: "base-resources"),
                    string(name: 'BRANCH', value: devops_repo_branch),
                    string(name: 'TF_VAR_client_version', value: env.image_version),
                    string(name: 'TF_VAR_client_image_tag', value: env.CLIENT_IMAGE_TAG),
                    string(name: 'TF_VAR_server_image_tag', value: env.SERVER_IMAGE_TAG),
                    credentials(name: 'DB_PASSWORD',value: 'TF-stage-mysql_password')
                ]
            }
        }

        stage ('Invoke Terraform: Provisioner:base_resources , Action:apply') {
            when {
                expression {
                    return env.BRANCH_NAME in environment_branches;
                    // Run only for stable branches and not PRs
                }
            }
            steps {
                build job: 'Deployments/Terraform-Deployment-Pipeline',
                wait: true,
                parameters: [
                    string(name: 'ENV', value: env.TERRAFORM_ENVIRONMENT),
                    string(name: 'ACTION', value: "apply"),
                    string(name: 'PROVISIONER', value: "base-resources"),
                    string(name: 'BRANCH', value: devops_repo_branch),
                    string(name: 'TF_VAR_client_version', value: env.image_version),
                    string(name: 'TF_VAR_client_image_tag', value: env.CLIENT_IMAGE_TAG),
                    string(name: 'TF_VAR_server_image_tag', value: env.SERVER_IMAGE_TAG),
                    credentials(name: 'DB_PASSWORD',value: 'TF-stage-mysql_password')
                ]
            }
        }

        stage ('Invoke Terraform: Provisioner:ecs , Action:plan') {
            when {
                expression {
                    return env.BRANCH_NAME in environment_branches;
                    // Run only for stable branches and not PRs
                }
            }
            steps {
                build job: 'Deployments/Terraform-Deployment-Pipeline',
                wait: true,
                parameters: [
                    string(name: 'ENV', value: env.TERRAFORM_ENVIRONMENT),
                    string(name: 'ACTION', value: "plan"),
                    string(name: 'PROVISIONER', value: "ecs"),
                    string(name: 'BRANCH', value: devops_repo_branch),
                    string(name: 'TF_VAR_client_version', value: env.image_version),
                    string(name: 'TF_VAR_client_image_tag', value: env.CLIENT_IMAGE_TAG),
                    string(name: 'TF_VAR_server_image_tag', value: env.SERVER_IMAGE_TAG),
                    credentials(name: 'DB_PASSWORD',value: 'TF-stage-mysql_password')
                ]
            }
        }

        stage ('Invoke Terraform: Provisioner:ecs , Action:apply') {
            when {
                expression {
                    return env.BRANCH_NAME in environment_branches;
                    // Run only for stable branches and not PRs
                }
            }
            steps {
                build job: 'Deployments/Terraform-Deployment-Pipeline',
                wait: true,
                parameters: [
                    string(name: 'ENV', value: env.TERRAFORM_ENVIRONMENT),
                    string(name: 'ACTION', value: 'apply'),
                    string(name: 'PROVISIONER', value: "ecs"),
                    string(name: 'BRANCH', value: devops_repo_branch),
                    string(name: 'TF_VAR_client_version', value: env.image_version),
                    string(name: 'TF_VAR_client_image_tag', value: env.CLIENT_IMAGE_TAG),
                    string(name: 'TF_VAR_server_image_tag', value: env.SERVER_IMAGE_TAG),
                    credentials(name: 'DB_PASSWORD',value: 'TF-stage-mysql_password')
                ]
            }
        }

        stage ('Stop Existing tasks and wait until service is stable') {
            when {
                expression {
                    return env.BRANCH_NAME in environment_branches;
                    // Run only for stable branches and not PRs
                }
            }
            steps {
                sh """
                    tasks=\$(aws ecs list-tasks \
                    --cluster ${appName}-${env.TERRAFORM_ENVIRONMENT}-ecs-cluster \
                    --service-name ${appName}-${env.TERRAFORM_ENVIRONMENT}-service \
                    --region eu-west-1 | jq -r '.taskArns[]')

                    echo "Stopping currently running tasks"
                    for task in \$tasks
                    do
                        echo "Stopping running task: \$task"
                        aws ecs stop-task --cluster ${appName}-${env.TERRAFORM_ENVIRONMENT}-ecs-cluster \
                        --reason "Stopped by Deployment Job" \
                        --task \$task \
                        --region eu-west-1

                        if [ \$? -eq 0 ]; then
                            echo "\$task stopped successfully"
                        else
                            echo "ERROR while stopping the task: \$task"
                        fi
                    done

                    echo "Waiting for Service to be stable"
                    aws ecs wait services-stable \
                        --cluster ${appName}-${env.TERRAFORM_ENVIRONMENT}-ecs-cluster \
                        --services ${appName}-${env.TERRAFORM_ENVIRONMENT}-service \
                        --region eu-west-1
                """
            }
        }
    }

    post {
        always {
            script {
                if (env.BRANCH_NAME == 'master') {
                    sh "docker rmi -f ${env.image_name}:${env.image_version}-${env.image_tag} logframelab/${env.image_name}:${env.image_version}-${env.image_tag}"
                    sh "docker rmi -f ${env.image_name}:${env.image_version}-${env.image_tag} logframelab/${env.image_name}:stagelatest"
                    sh "docker rmi -f ${env.image_name}:${env.image_version}-${env.image_tag}"
                }

                else if (env.BRANCH_NAME == 'develop') {
                    sh "docker rmi -f ${env.image_name}:${env.image_version}-${env.image_tag} logframelab/${env.image_name}:${env.image_version}-${env.image_tag}"
                    sh "docker rmi -f ${env.image_name}:${env.image_version}-${env.image_tag} logframelab/${env.image_name}:devlatest"
                    sh "docker rmi -f ${env.image_name}:${env.image_version}-${env.image_tag}"
                }

                else if (KEEP_IMAGE == true) {
                    sh "docker rmi -f ${env.image_name}:${env.image_version}-${env.image_tag}"
                    sh "docker rmi -f logframelab/${env.image_name}:${env.image_version}-${env.image_tag}"
                }

            }
            cleanWs()
        }
    }
}